class PegasusDSL < SwitchDSL
  def initialize(remote)
    super()
    @remote = remote
    @permissions_cache = []
  end

  attr_accessor :remote
  
  def command(a, b, &block)
    @remote.command(a, b, &block)
  end
  
  def read(pointer, offset, length, &block)
    @remote.command("read", {:address => pack64(pointer.to_i+offset), :length => length}, &block)
  end

  def write(pointer, offset, data)
    @remote.command("write", {:address => pack64(pointer.to_i+offset), :payload => Base64.strict_encode64(data)})
  end

  def memory_permissions(addr)
    addr = addr.to_i
    e = @permissions_cache.find do |e|
      e.offset <= addr && (e.offset + e.length) > addr
    end
    if e then
      return e.perms
    end

    memInfo = new Types::MemInfo
    pageInfo = new Types::PageInfo
    SVC::QueryMemory.call(memInfo, pageInfo, make_pointer(addr))
    struct = memInfo.deref
    free pageInfo
    free memInfo

    entry = PermissionCacheEntry.new(struct.base.to_i, struct.pageSize, struct.memoryPermissions)
    @permissions_cache.push entry
    return entry.perms
  end
  
  def base_addr
    @base_addr||= make_pointer(unpack64(@remote.command("get", {:field => "baseAddr"})["value"]))
  end
  
  def main_addr
    @main_addr||= make_pointer(unpack64(@remote.command("get", {:field => "mainAddr"})["value"]))
  end
  
  def sp
    @sp||= make_pointer(unpack64(@remote.command("get", {:field => "sp"})["value"]))
  end

  def tls
    @tls||= make_pointer(unpack64(@remote.command("get", {:field => "tls"})["value"]))
  end

  def unpack64(pair)
    pair.pack("L<L<").unpack("Q<")[0]
  end

  def pack64(val)
    [val].pack("Q<").unpack("L<L<")
  end
  
  def mref(off)
    main_addr + off
  end
  
  def invoke_gc
    @remote.command("invokeGC", {})
    nil
  end
  
  def malloc(size)
    make_pointer(unpack64(@remote.command("malloc", {:length => size})["address"]))
  end

  def free(pointer)
    @remote.command("free", {:address => pack64(pointer.value)})
  end

  def call(func_ptr, int_args, registers, float_args)
    unpack64(@remote.command("invokeBridge", {
                               :funcPtr => pack64(func_ptr.value),
                               :intArgs => int_args.map do |v| pack64(v) end,
                               :registers => registers.map do |v| pack64(v) end,
                               :floatArgs => float_args.map do |v| pack64(v) end
                             })["returnValue"])
  end
  
  def jsrepl
    require "readline"
    while buf = Readline.readline("> ", true) do
      if buf == "exit" || buf == "quit" then
        break
      else
        begin
          puts @remote.command("eval", {:code => buf})["returnValue"]
        rescue => e
          puts e.inspect
        end
      end
    end
  end

  PermissionCacheEntry = Struct.new("PermissionCacheEntry", :offset, :length, :perms)
end
