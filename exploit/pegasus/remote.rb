require "bundler/setup"
require "websocket-eventmachine-server"
require "em-http-server"
require "thread"
require "json"
require "pry"
require "base64"
require "socket"

require_relative "./dsl.rb"

module Exploit
  module Pegasus
    class RemoteSwitch
      def initialize(ws, cmdQueue, binQueue)
        @ws = ws
        @cmdQueue = cmdQueue
        @binQueue = binQueue
      end
      
      def command(type, params)
        jobTag = (Time.now.to_f * 1000).to_i
        json = JSON.generate({:command => type, :jobTag => jobTag}.merge(params))
        @ws.send json

        response = @cmdQueue.pop
        if response["command"] != "return" then
          raise "Got bad resposne packet: " + response.to_s
        end

        if response["jobTag"] != jobTag then
          raise "got back wrong job tag"
        end
        if response["error"] then
          raise "remote error: " + response["error"].to_s
        end

        isBinary = response["binaryPayload"]
        if isBinary then
          if response["binaryLength"] < 0 then # multi stream
            packet = @cmdQueue.pop
            while packet["type"] != "finish" do
              chunk = nil
              if packet["hasChunk"] then
                chunk = @binQueue.pop
                if chunk.length != packet["length"] then
                  raise "chunk length mismatch"
                end
              end
              yield packet["header"], chunk
              
              packet = @cmdQueue.pop
            end
          else # regular stream
            buf = String.new
            while buf.length < response["binaryLength"] do
              buf+= @binQueue.pop
              if block_given? then
                yield buf, buf.length, response["binaryLength"] # report progress
              end
            end
            return buf
          end
        else
          return response["response"]
        end
      end
    end

    class HTTPHandler < EM::HttpServer::Server
      def initialize(binQueue)
        super
        @binQueue = binQueue
      end
      
      def process_http_request
        response = EM::DelegatedHttpResponse.new(self)
        response.headers["Access-Control-Allow-Origin"] =  "*"
        response.headers["Access-Control-Allow-Headers"] =  "Content-Type"
        response.status = 200
        response.send_response
        
        if @http_request_method == "POST" then
          @binQueue.push @http_content
        end
      end
    end

    def self.get_dsl
      wsQueue = Queue.new
      cmdQueue = Queue.new
      binQueue = Queue.new
      
      Thread.new do
        EM.run do
          WebSocket::EventMachine::Server.start(:host => "0.0.0.0", :port => 8080) do |ws|
            ws.onopen do |handshake|
              wsQueue.push ws
            end
            
            ws.onclose do
              puts "Connection closed"
            end
            
            ws.onmessage do |msg, type|
              if type == :text then
                data = JSON.parse(msg)
                if data["command"] == "log" then
                  puts data["message"]
                else
                  cmdQueue.push data
                end
              elsif type == :binary then
                binQueue.push msg
              else
                puts "?!?!"
              end
            end
            
            ws.onerror do |err|
              puts "got error: " + err.to_s
            end
          end
          
          EM::start_server("0.0.0.0", "8081", HTTPHandler, binQueue)
        end
        
        at_exit do
          EventMachine::stop_event_loop
        end
      end
      
      puts "Waiting for connection from switch..."
      ws = wsQueue.pop
      puts "Got connection from switch at " + Socket.unpack_sockaddr_in(ws.get_peername)[1]
      ws.onclose do
        puts "Lost connection from switch"
        
        EventMachine::stop_event_loop
        exit 1
      end
      
      dsl = PegasusDSL.new(RemoteSwitch.new(ws, cmdQueue, binQueue))
      bind = dsl.instance_eval do
        binding
      end
      dsl.bind = bind
      
      Pry.config.hooks.delete_hook(:before_session, :default)
      
      begin
        bind.eval(File.read("standard_switch.rb"), "standard_switch.rb")
      rescue => e
        puts e
        puts e.backtrace
      end
    end
  end
end

$exploitMap["pegasus"] = Exploit::Pegasus
